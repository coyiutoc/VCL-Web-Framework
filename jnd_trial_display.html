<!DOCTYPE html>
<html>
<head>
    <!-- Scripts: -->

    <!-- Local scripts: -->
    <script type="text/javascript" src="scripts/gaussian_distribution_generator.js" ></script> 
    <script type="text/javascript" src="scripts/adjust_correlation.js" ></script>
    <script type="text/javascript" src="scripts/jnd_experiment_helpers.js" ></script>

    <!-- Math.js: -->
    <script src="https://unpkg.com/mathjs@4.4.2/dist/math.min.js"></script>

    <!-- D3: -->
    <script src = "https://d3js.org/d3.v4.min.js"></script>

    <!-- Style: -->
    <link rel="stylesheet" href="styles.css">

</head>
<body>
  <div align = "center">

    <!-- For margin buffer: -->
    <svg width="400" height="180">
    <div id="graph">

    </div>

    <script type="text/javascript">

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // NOTE: If testing this file independent of jnd_experiment.html,
    //       uncomment all variables encapsulated in this !!!! block.

    // Constants -----------------------------------------------------

    // const MIN_CORRELATION = 0.0
    // const MAX_CORRELATION = 1.0
    // const BASE_CORRELATION = 0.3

    // const NUM_POINTS = 100;
    // const ERROR = 0.0001;
    // const NUM_SD = 2.5;
    // const SD = 0.2;
    // const MEAN = 0.5;
    // const INITIAL_DIFFERENCE = 0.1;
    // const CONVERGE_FROM_ABOVE = true;
    // const MAX_STEP_SIZE = 0.01;

    // // Generate distribution -----------------------------------------

    // var left_coordinates = generateDistribution(BASE_CORRELATION, ERROR, NUM_POINTS, NUM_SD, MEAN, SD);

    // if (CONVERGE_FROM_ABOVE){
    //   adjustedCorrelation = Math.min(MAX_CORRELATION, BASE_CORRELATION + INITIAL_DIFFERENCE); }
    // else{
    //   adjustedCorrelation = Math.max(MIN_CORRELATION, BASE_CORRELATION - INITIAL_DIFFERENCE);
    // };

    // var right_coordinates = generateDistribution(adjustedCorrelation, ERROR, NUM_POINTS, NUM_SD, MEAN, SD);

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // Prepare Data --------------------------------------------------

    var left_dataset = prepareCoordinates(left_coordinates, multiplier);
    var right_dataset = prepareCoordinates(right_coordinates, multiplier);

    var datasets = [left_dataset, right_dataset];

    // Graphing ------------------------------------------------------

    var width = 400;
    var height = 400;

    // Create scales:
    // ** D3 creates a function that takes in input between [0, 100] and 
    //    outputs between [0, width].
    //    Basically, domain = input, range = ouput. 
    var xscale = d3.scaleLinear()
                   .domain([0, multiplier]) 
                   .range([0, width]);

    var yscale = d3.scaleLinear()
                   .domain([0, multiplier])
                   .range([height/2, 0]);

    // Create axes: 
    var x_axis = d3.axisBottom()
                   .scale(xscale)
                   .tickSize([0]);

    var y_axis = d3.axisLeft()
                   .scale(yscale)
                   .tickSize([0]);

    // Create/append the SVG for both graphs: 
    for (var data of datasets){
      
      var chart = d3.select("#graph") // Insert into the div w/ id = "graph"
                    .append("svg") 
                      .attr("width", width + 60) // Width and height of the SVG viewpoint
                      .attr("height", height);   // +40 is for buffer (points going -x)

      // Creating transform SVG elements + append to SVG: 
      var yAxisElements = chart.append("g")
                                 .attr("transform", "translate(50, 10)")
                                 .call(y_axis);

      yAxisElements.selectAll("text").remove(); // Remove tick labels

      var xAxisTranslate = height/2 + 10;
      var xAxisElements = chart.append("g")
                                .attr("transform", "translate(50, " + xAxisTranslate  +")")
                                .call(x_axis)

      xAxisElements.selectAll("text").remove(); // Remove tick labels 

      // Populating data: 
      chart.selectAll("circle") // Technically no circles inside div yet, but will be creating it
            .data(data)
              .enter()
              .append("circle") // Creating the circles for each entry in data set 
              .attr("cx", function (d) { // d is a subarray of the dataset i.e coordinates [5, 20]
                return xscale(d[0]) + 60; // +60 is for buffer (points going -x, even if they are positive)
              })
              .attr("cy", function (d) {
                return yscale(d[1]);
              })
              .attr("r", 2);
    }

    </script>
  </div>
</body>
</html>
