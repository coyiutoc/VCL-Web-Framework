<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">scripts/experiments/stevens/stevens.js | VCL Framework</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<script src="./inject/script/0-conditions-config.js"></script><script src="./inject/script/0-experiments-config.js"></script><script src="./inject/script/0-graphing-config.js"></script><script src="./inject/script/0-trial-structure-config.js"></script><script src="./inject/script/0-balancing-config.js"></script><script src="./inject/script/0-view-controller.js"></script><script src="./inject/script/0-experiments-renderer.js"></script><script src="./inject/script/0-conditions-renderer.js"></script><script src="./inject/script/0-supported-properties-renderer.js"></script><link rel="stylesheet" href="./inject/css/0-styles.css"><meta name="description" content="This is a Node.js application that runs proof of concept experiments for the following:"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="VCL Framework"><meta property="twitter:description" content="This is a Node.js application that runs proof of concept experiments for the following:"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/coyiutoc/VCL_Correlation_POC"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#experiment-properties-balancing">experiment-properties/balancing</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-initialize_latin_square">initialize_latin_square</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-initialize_random_order">initialize_random_order</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#experiment-properties-data">experiment-properties/data</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get_subconditions">get_subconditions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-create_condition_dataset">create_condition_dataset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get_data">get_data</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get_data_subset">get_data_subset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CUSTOM_TRIAL_STRUCTURE_CONDITIONS">CUSTOM_TRIAL_STRUCTURE_CONDITIONS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-EXPERIMENT_BASES">EXPERIMENT_BASES</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-EXPERIMENT_CONDITIONS">EXPERIMENT_CONDITIONS</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#experiment-properties-data-constants">experiment-properties/data/constants</a><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ESTIMATION_BASE">ESTIMATION_BASE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-JND_BASE">JND_BASE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-JND_CONDITIONS">JND_CONDITIONS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-JND_RADIUS_BASE">JND_RADIUS_BASE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-JND_RADIUS_CONDITIONS">JND_RADIUS_CONDITIONS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-STEVENS_BASE">STEVENS_BASE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-STEVENS_CONDITIONS">STEVENS_CONDITIONS</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#experiment-properties-graphing">experiment-properties/graphing</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-is_custom_plot">is_custom_plot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-prepare_custom_plot">prepare_custom_plot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-plot_distributions">plot_distributions</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#experiment-properties-graphing-d3-base-plots">experiment-properties/graphing/d3-base-plots</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-create_ring_plot">create_ring_plot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-create_scatter_plot">create_scatter_plot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-plot_scatter_points">plot_scatter_points</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-create_shape_plot">create_shape_plot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-create_strip_plot">create_strip_plot</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#experiment-properties-graphing-d3-custom-plots">experiment-properties/graphing/d3-custom-plots</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-create_distractor_scatter_plot">create_distractor_scatter_plot</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#experiments-estimation">experiments/estimation</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/experiments/estimation/estimation.js~Estimation.html">Estimation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-estimation_exp">estimation_exp</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#experiments-jnd">experiments/jnd</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/experiments/jnd/jnd.js~JND.html">JND</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-jnd_exp">jnd_exp</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#experiments-jnd-radius">experiments/jnd_radius</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/experiments/jnd_radius/jnd_radius.js~JND_Radius.html">JND_Radius</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-jnd_radius_exp">jnd_radius_exp</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#experiments-stevens">experiments/stevens</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/experiments/stevens/stevens.js~Stevens.html">Stevens</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-stevens_exp">stevens_exp</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#helpers">helpers</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-force_greater_right_position">force_greater_right_position</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-randomize_position">randomize_position</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-randomize_radius_position">randomize_radius_position</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">scripts/experiments/stevens/stevens.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// import {generateDistribution} from &quot;/scripts/generators/gaussian_distribution_generator.js&quot;;
import {initialize_latin_square} from &quot;/scripts/experiment-properties/balancing/latin_square_generator.js&quot;;
import {initialize_random_order} from &quot;/scripts/experiment-properties/balancing/random_generator.js&quot;;
import {get_data, 
        get_data_subset} from &quot;/scripts/experiment-properties/data/data_controller.js&quot;;
import {randomize_position,
        randomize_radius_position,
        force_greater_right_position} from &quot;/scripts/helpers/experiment_helpers.js&quot;;

export default class Stevens {

  /**
   * Initializes a Stevens experiment object. 
   *
   * @param  params {assoc array}  Parameters passed from routing.
   */
  constructor(params) {

    let trial_structure = params[&quot;trial_structure&quot;];
    let condition_name = params[&quot;condition&quot;];
    let graph_type = params[&quot;graph_type&quot;];
    let balancing_type = params[&quot;balancing&quot;];

    this.condition_name = condition_name; 
    this.condition_group = this.condition_name.split(&apos;_&apos;)[0]; // Mostly to handle &quot;distractor&quot; conditions.
                                                              // TODO: Should have a better flag for it.
    this.subject_id = params[&quot;subject_id&quot;];
    this.subject_initials = params[&quot;subject_initials&quot;];

    // ========================================
    // PARAMETER CHECKING

    // **NOTE: EXPERIMENTS variable comes from /public/config/experiments-config.js
    if (!EXPERIMENTS[&quot;stevens&quot;][&quot;trial_structure&quot;].includes(trial_structure)) {
      throw Error(trial_structure + &quot; is not supported.&quot;);}
    else {
      this.trial_structure = trial_structure;
    }

    if (!EXPERIMENTS[&quot;stevens&quot;][&quot;graph_type&quot;].includes(graph_type)){
      throw Error(graph_type + &quot; is not supported.&quot;)} 
    else { 
      this.graph_type = graph_type;
    };  

    if (!EXPERIMENTS[&quot;stevens&quot;][&quot;balancing_type&quot;].includes(balancing_type)) {
      throw Error(balancing_type + &quot; is not supported.&quot;) }
    else {
      this.balancing_type = balancing_type;
    }  

    // ========================================
    // EXPERIMENT CONSTANTS

    this.MAX_STEP_INTERVAL = 10;

    // ========================================
    // EXPERIMENT VARIABLES

    this.input_count_array; // Array of length trials_per_round, each index representing num inputs per round 
                            // for a given sub condition
    this.sub_conditions_constants;
    this.current_sub_condition_index;
    this.round_end = false;

    // ========================================
    // PRACTICE EXPERIMENT VARIABLES

    this.practice_conditions_constants;
    this.adjusted_midpoint_matrix = {}; 
    this.practice_trial_data = {};
    this.practice_end = false;

    // ========================================
    // TEST EXPERIMENT VARIABLES

    this.experiment_conditions_constants;
    this.sub_condition_order = [];

    // ========================================
    // CURRENT TRIAL DATA

    // Plotting-related vars
    this.left_coordinates = &quot;&quot;;
    this.right_coordinates = &quot;&quot;;
    this.middle_coordinates = &quot;&quot;;
    this.distractor_coordinates = &quot;&quot;;

    // JsPsych trial_data for the current trial
    this.trial_data = &quot;&quot;;

    // ========================================
    // PREPARE EXPERIMENT

    // Extract raw constants
    this.raw_constants = get_data(this);
    
    // Prepare experiment + practice data
    this.prepare_experiment();
    this.prepare_practice();  

  }

  /**
   * Orders the input data according to balancing type and
   * initializes the Stevens object&apos;s variables.  
   *
   * @param  balancing_type {string}                           Type of balancing. Currently only latin_square
   *                                                           is supported.
   *         dataset {[{assoc array}, {assoc array}, ... ]}   The data to be ordered. 
   */
  prepare_experiment() {

    let dataset = this.raw_constants;

    var ordered_dataset = [];

    switch (this.trial_structure) {

      case &quot;foundational&quot;:
        this.set_foundational_dataset_order(dataset);
        break;

      case &quot;design&quot;:
        this.set_design_dataset_order(dataset);
        break;

      case &quot;custom&quot;:
        ordered_dataset = dataset;
        break;
    }

    // Order the data set according to the latin square
    for (let i=0; i &lt; this.sub_condition_order.length; i++){
      ordered_dataset[i] = dataset[this.sub_condition_order[i]];

      // Alternate the start ref to be low or high for each subcondition
      if (i%2 === 0) {
        ordered_dataset[i][&quot;start_ref&quot;] = ordered_dataset[i][&quot;low_ref&quot;];
      } else {
        ordered_dataset[i][&quot;start_ref&quot;] = ordered_dataset[i][&quot;high_ref&quot;];
      }
    }

    // Set experiment trials
    this.experiment_conditions_constants = ordered_dataset;    
  }

  /**
   * Creates the practice dataset by taking the first FOUR subconditions.
   *
   * @param  dataset {[{assoc array}, {assoc array}, ... ]}   The data to be ordered. 
   */
  prepare_practice() {

    let dataset = this.raw_constants;
    let practice_dataset = [];

    for (let i=0; i &lt; 4; i++){
      practice_dataset[i] = dataset[i];
      this.practice_trial_data[i] = [];

      // Alternate the start ref to be low or high for each subcondition
      if (i%2 === 0) {
        practice_dataset[i][&quot;start_ref&quot;] = dataset[i][&quot;low_ref&quot;];
      } else {
        practice_dataset[i][&quot;start_ref&quot;] = dataset[i][&quot;high_ref&quot;];
      }
    }

    this.sub_conditions_constants = practice_dataset;
    this.current_sub_condition_index = 0; 
    this.input_count_array = new Array(this.sub_conditions_constants[0].trials_per_round).fill(0);
  }

  /**
   * Sets the subcondition order for design range.
   *
   * @param  dataset {[{assoc array}, {assoc array}, ... ]}   The data used to be ordered. 
   */
  set_design_dataset_order(dataset) {

    switch(this.balancing_type) {

      case &apos;latin_square&apos;:
        this.sub_condition_order = initialize_latin_square(dataset.length);
        break;

      case &apos;random&apos;:
        this.sub_condition_order = initialize_random_order(dataset.length);
        break;

      default:
        throw Error(this.balancing_type + &quot; balancing type is not supported.&quot;);
    }
  }

  /**
   * Sets the subcondition order for foundational range.
   * Needs to balance INDIVIDUALLY the round and test type conditions,
   * then maintain that order (e.g. all test goes first, then consistency)
   *
   * @param  dataset {[{assoc array}, {assoc array}, ... ]}   The data used to be ordered. 
   */
  set_foundational_dataset_order(dataset) {

    // To hold individual data sets according to round type
    var test_dataset = [];
    var consistency_dataset = [];

    // To hold balanced indexes
    var test_order = []; 
    var consistency_order = [];

    // Extract dataset according to test or consistency round type
    for (let subcondition of dataset) {

      if (subcondition[&quot;round_type&quot;] === &quot;test&quot;) {
        test_dataset.push(subcondition);
      } else {
        consistency_dataset.push(subcondition);
      }
    }

    // Get balancing order for EACH round type dataset individually
    switch(this.balancing_type) {

      case &apos;latin_square&apos;:
        test_order = initialize_latin_square(test_dataset.length);
        consistency_order = initialize_latin_square(consistency_dataset.length);
        break;

      case &apos;random&apos;:
        test_order = initialize_random_order(test_dataset.length);
        consistency_order = initialize_random_order(consistency_dataset.length);
        break;

      default:
        throw Error(this.balancing_type + &quot; balancing type is not supported.&quot;);
    }

    // Since test dataset will run first, add index length of it to consistency order
    for (let i = 0; i &lt; consistency_order.length; i++) {
      consistency_order[i] += test_dataset.length;
    }

    //  Merge the two orders 
    this.sub_condition_order = test_order.concat(consistency_order);
  }

  /**
   * Resets all relevant variables to now use the test version.
   * (input_count_array, sub_conditions_constants, and current_sub_condition_index
   * are shared variables between the practice and test trials).
   *
   * This function is called once all the practice trials have run. 
   */
  end_practice_experiment() {
    this.sub_conditions_constants = this.experiment_conditions_constants;
    this.input_count_array = new Array(this.sub_conditions_constants[0].trials_per_round).fill(0);
    this.current_sub_condition_index = 0;
  }

  /**
   * Calculates exclusion criteria using standard deviation and variance.
   * Subcondition is flagged if:
   * - Standard deviation &gt; 0.2
   * - Anchoring &gt; 0.6
   *
   * @ return     HTML of subcondition data to print onto screen
   */
  calculate_exclusion_criteria() {

    let string = &quot;&quot;;

    for (let i = 0; i &lt; Object.keys(this.practice_trial_data).length; i++) {

      let subcondition_data = this.practice_trial_data[i];
      let mids = this.get_estimated_mids(subcondition_data);

      let std_dev = this.get_standard_deviation(mids);
      let anchoring_value = this.get_anchoring_value(mids);

      let rounded_mids = [];
      for (let mid of mids) {
        rounded_mids.push(mid.toFixed(3));
      }

      let anchoring_color = &quot;BLACK&quot;;
      if (anchoring_value &gt; 0.5) {
        anchoring_color = &quot;RED&quot;;
      }

      let std_dev_color = &quot;BLACK&quot;;
      if (std_dev &gt; 0.2) {
        std_dev_color = &quot;RED&quot;;
      }

      string += `
        &lt;div align = &quot;center&quot; style = &quot;text-align: left; float:left; width: 20vw&quot;&gt;
        &lt;font size = 2&gt;&lt;b&gt; Subcondition: ${i+1} &lt;/b&gt;
        &lt;br&gt;
        Midpoint values: ${rounded_mids}
        &lt;br&gt;
        &lt;font color = ${std_dev_color}&gt; Standard Deviation: ${std_dev} &lt;/font&gt;
        &lt;br&gt;
        &lt;font color = ${anchoring_color}&gt; Anchoring Value: ${anchoring_value} &lt;/font&gt;
        &lt;br&gt;
        &lt;br&gt;
        &lt;/font&gt;
        &lt;/div&gt;
        `
    }

    return string;
  }

  /**
   * Calculates the standard deviation for the specified subcondition.
   * @ param  {array}   array of estimated mids for that trial
   *
   * @ return {double}  standard deviation
   */
  get_standard_deviation(estimated_mids) {

    let values = [];

    // Calculate mean:
    let mean = 0;
    for (let mid of estimated_mids) {
      mean += mid;
    }
    mean = mean / estimated_mids.length;

    // Calculate variance:
    let variance = 0;
    for (let mid of estimated_mids) {
      variance += Math.pow(mid - mean, 2);
    }
    variance = variance / (estimated_mids.length - 1);

    return Math.sqrt(variance).toFixed(3);
  }

  /**
   * Calculates the anchoring value for the specified subcondition.
   * @ param  {array}   array of estimated mids for that trial
   *
   * @ return {double} anchoring value
   */
  get_anchoring_value(estimated_mids) {

    let high_ref_trial_sum = 0;
    let low_ref_trial_sum = 0;

    // Iterate through each estimated mid (trial) of a given subcondition
    for (let i = 0; i &lt; estimated_mids.length; i++) {
      // Evens have the low ref as their starter 
      if (i % 2 === 0) {
        low_ref_trial_sum += estimated_mids[i];
      } else {
        high_ref_trial_sum += estimated_mids[i];
      }
    }

    return Math.abs(high_ref_trial_sum - low_ref_trial_sum).toFixed(3);
  }

  /**
   * Retrieves the estimated midpoints of each trial for the subcondition.
   *
   * @ return {array}  of estimated mids 
   */
  get_estimated_mids(subcondition_data) {

    let estimated_mids = [];

    for (let trial of subcondition_data) {
      estimated_mids.push(trial.estimated_mid);
    }

    return estimated_mids;
  }

  /**
   * Generates a Stevens object for use in the JsPsych timeline.
   *
   * @param  type {string}                             &quot;test&quot; or &quot;practice&quot;
   * @return trial {object}
   */   
  generate_trial(block_type) {

    if ((block_type !== &quot;test&quot;) &amp;&amp; (block_type !== &quot;practice&quot;)) {throw Error(block_type + &quot; is not supported.&quot;)};

    // Initialize a variable for this so it is usable inside on_start
    var stevens_exp = this; 
    var address = location.protocol + &quot;//&quot; + location.hostname + &quot;:&quot; + location.port + &quot;/stevens_trial&quot;; 

    var trial = {
        type:&apos;external-html-keyboard-response&apos;,
        url: address,
        choices: [77, 90, 32, 81],  // m = 77 (up), z = 90 (down), 32 = spacebar, 81 = q (exit button for debugging)
        execute_script: true,
        response_ends_trial: true, 
        data: {},
        on_start: function(trial){ // NOTE: on_start takes in trial var 

          // Set the constants to be used:
          var index = stevens_exp.current_sub_condition_index; 
          var constants = stevens_exp.sub_conditions_constants[index];

          // Retrieve data from last trial:
          var last_stevens_trial = stevens_exp.get_last_trial(trial, block_type, index);

          // Handling saving the data: 
          stevens_exp.handle_data_saving(trial, block_type, constants, estimated_correlation, last_stevens_trial, index);

          // Set the estimated correlation
          var estimated_correlation = stevens_exp.update_estimated_correlation(trial, constants, last_stevens_trial);

          console.log(&quot;round refreshes: &quot; + trial.data.round_refreshes);
          console.log(&quot;trial/round num: &quot; + trial.data.trial_num);
          console.log(&quot;num adjustments: &quot; + trial.data.num_adjustments);
          console.log(&quot;input count per trial: &quot; + stevens_exp.input_count_array);

          // Generate distributions
          var high_coordinates = generateDistribution(constants.high_ref, 
                                                      constants.error, 
                                                      constants.num_points, 
                                                      constants.num_SD, 
                                                      constants.mean, 
                                                      constants.SD);
          
          var low_coordinates = generateDistribution(constants.low_ref, 
                                                     constants.error, 
                                                     constants.num_points, 
                                                     constants.num_SD, 
                                                     constants.mean,
                                                     constants.SD);
          
          var estimated_coordinates = generateDistribution(estimated_correlation, 
                                                        constants.error, 
                                                        constants.num_points, 
                                                        constants.num_SD, 
                                                        constants.mean, 
                                                        constants.SD);
          
          // If there is a distractor population, generate it:
          if (stevens_exp.condition_group === &quot;distractor&quot;) {
            stevens_exp.generate_distractor_coordinates(constants);
          }

          // Randomize position of the high and low correlated graphs for a given round
          if (trial.data.round_refreshes == 1){
            var result = randomize_position(trial, 
                                           high_coordinates,
                                           low_coordinates, 
                                           constants.high_ref, 
                                           constants.low_ref);
            trial.data.high_ref_is_right = result.base_is_right;
          }

          if (trial.data.high_ref_is_right){
            stevens_exp.right_coordinates = high_coordinates;
            stevens_exp.left_coordinates = low_coordinates;
            stevens_exp.coordinates = [low_coordinates, estimated_coordinates, high_coordinates];
          }
          else{
            stevens_exp.right_coordinates = low_coordinates;
            stevens_exp.left_coordinates = high_coordinates;
            stevens_exp.coordinates = [high_coordinates, estimated_coordinates, low_coordinates];
          }

          stevens_exp.trial_data = trial.data; 

          console.log(&quot;[RIGHT] Correlation: &quot; + trial.data.right_correlation);
          console.log(&quot;[MIDPOINT] Correlation: &quot; + trial.data.estimated_mid);
          console.log(&quot;[LEFT] Correlation: &quot; + trial.data.left_correlation);
        }
      };

    return trial; 
  }

  /**
   * Will generate the distractor coordinates and save them to the instance.
   *
   * @param  {object}  constants (for the given trial)       
   */
  generate_distractor_coordinates(constants) {

    let left_dist_coordinates = generateDistribution(constants.dist_base,
                                                           constants.dist_error,
                                                           constants.dist_num_points,
                                                           constants.num_SD,
                                                           constants.mean,
                                                           constants.SD);
    
    let middle_dist_coordinates = generateDistribution(constants.dist_base,
                                                           constants.dist_error,
                                                           constants.dist_num_points,
                                                           constants.num_SD,
                                                           constants.mean,
                                                           constants.SD);

    let right_dist_coordinates = generateDistribution(constants.dist_base,
                                                           constants.dist_error,
                                                           constants.dist_num_points,
                                                           constants.num_SD,
                                                           constants.mean,
                                                           constants.SD);

    this.distractor_coordinates = [left_dist_coordinates, middle_dist_coordinates, right_dist_coordinates];
  }

  /**
   * Retrieves the last stevens trial depending on block_type for a
   * given sub condition index. 
   * If this is the first trial of a given block_type, returns null. 
   *
   * @param  trial {object}   
   *         block_type {string}          &quot;test&quot; or &quot;practice&quot;         
   *         index {integer}
   * @return last_stevens_trial {object}           
   */
  get_last_trial(trial, block_type, index) {

    var last_stevens_trial; 
    trial.data.type = &quot;stevens&quot;;
    
    // Set trial run_type depending on block type
    // (we need to set trial&apos;s run_type so we can do the filter in the
    // next if block)
    if (block_type == &quot;test&quot;){
      trial.data.run_type = &quot;test&quot;;
    }
    else{
      trial.data.run_type = &quot;practice&quot;;
    }

    // Retrieve previous stevens trial if it exists
    if (block_type == &quot;practice&quot; &amp;&amp; jsPsych.data.get().filter({type: &quot;stevens&quot;, run_type: &quot;practice&quot;, sub_condition: index}).last(1).values()[0]){
      last_stevens_trial = jsPsych.data.get().filter({type: &quot;stevens&quot;, run_type: &quot;practice&quot;, sub_condition: index}).last(1).values()[0];
    }
    else if (block_type == &quot;test&quot; &amp;&amp; jsPsych.data.get().filter({type: &quot;stevens&quot;, run_type: &quot;test&quot;, sub_condition: index}).last(1).values()[0]){
      last_stevens_trial = jsPsych.data.get().filter({type: &quot;stevens&quot;, run_type: &quot;test&quot;, sub_condition: index}).last(1).values()[0];
    }
    else{
      last_stevens_trial = null;
    }

    return last_stevens_trial; 
  }

  /**
   * Handles saving the relevant data on a given trial.
   *
   * For reference, these are the helper variables created to assist in trial logic (i.e not present in excel)
   * this.trial_variables =         
   *       {type: &apos;stevens&apos;,
   *       run_type: &apos;&apos;,
   *       left_correlation: &apos;&apos;,
   *       right_correlation: &apos;&apos;,
   *       round_refreshes: 0,      // Number of times there is a refresh for a given round 
   *       high_ref_is_right: false
   *       start_ref: &apos;&apos;
   *       };
   *
   * These are variables created WITHIN the trial logic that were not present in excel (but need to be
   * outputted to results).         
   * this.export_variables = 
   *       {trial_num: 0,                // Round index trial is currently on (aka trial_num from excel)
   *        sub_condition: &apos;&apos;,           // Chronological ordering of sub_condition [1, 2, 3 ... ]
   *        balanced_sub_condition: &apos;&apos;,  // Index of sub_condition according to balancing order
   *        estimated_mid: &apos;&apos;,
   *        num_adjustments: 0,          // Number of inputs for a given round (aka num_adjustments from excel)
   *        trials_per_round: &apos;&apos;,
   *       };
   *
   * @param trial {object}
   *        block_type {string}               &quot;test&quot; or &quot;practice&quot;
   *        constants {assoc array}
   *        estimated_correlation {double}
   *        last_stevens_trial {object}
   *        index {integer}
   */
  handle_data_saving(trial, block_type, constants, estimated_correlation, last_stevens_trial, index) {

    trial.data = Object.assign({}, trial.data, constants);

    trial.data.sub_condition = index;
    trial.data.balanced_sub_condition = this.sub_condition_order[index];

    trial.trial_duration = trial.data.regen_rate;

    // If trial is still part of same sub-condition, carry over constants from
    // the previous trial
    if (last_stevens_trial){

      trial.data.step_size = last_stevens_trial.step_size;
      trial.data.right_correlation = last_stevens_trial.right_correlation;
      trial.data.left_correlation = last_stevens_trial.left_correlation;
      trial.data.high_ref_is_right = last_stevens_trial.high_ref_is_right;

      // If a round has just ended:
      // - increment the trial_num
      // - set refresh number back to 1
      // - reset the number of adjustments to 0
      // - swap the start ref to be high/low depending on the previous round&apos;s start ref
      if (this.round_end == true){

        trial.data.trial_num = last_stevens_trial.trial_num + 1;
        trial.data.num_adjustments = 0;
        trial.data.round_refreshes = 1;

        if (last_stevens_trial.start_ref === constants.high_ref) {
          trial.data.start_ref = constants.low_ref;
        } else {
          trial.data.start_ref = constants.high_ref;
        }

        this.round_end = false; //Reset flag
      }
      // Else trial_num, num_adjustments and start_ref is the same, but round_refresh ++ 
      else{
        trial.data.trial_num = last_stevens_trial.trial_num;
        trial.data.num_adjustments = last_stevens_trial.num_adjustments;
        trial.data.start_ref = last_stevens_trial.start_ref;
        trial.data.round_refreshes = last_stevens_trial.round_refreshes + 1;
      }
    }
    // Else this is the first refresh of a given trial 
    else{
      trial.data.trial_num = 0;
      trial.data.num_adjustments = 0;
      trial.data.round_refreshes = 1;
    }
  }

  /**
   * Updates the estimated correlation.
   * If  : 
   *    Is the first trial, will initialize the correlation and step size.
   * Else:
   *    If there was a key press in previous trial, will calculate the
   *    the estimated correlation (depending on whether it was an inc or dec).
   *    Else if no key press in previous trial, will set estimated correlation
   *    to the previous trial&apos;s. 
   *
   * @param  trial {object}   
   *         constants {object}         
   *         last_trial {object}
   * @return estimated_correlation {double}           
   */
  update_estimated_correlation(trial, constants, last_trial) {

    var estimated_correlation;
    var index = this.current_sub_condition_index;

    // If first trial (estimated_correlation is null), so initialize
    // estimated midpoint and set step size:
    if (trial.data.round_refreshes == 1){
  
      //Initialize the estimated midpoint correlation:
      //estimated_correlation = Math.random() &lt; 0.5 ? constants.low_ref : constants.high_ref;
      estimated_correlation = trial.data.start_ref;
      trial.data.estimated_mid = estimated_correlation;
      trial.data.step_size = (constants.high_ref - constants.low_ref) / this.MAX_STEP_INTERVAL;

    }
    // If there is input on PREVIOUS trial, change the midpoint + increment trial number
    // (Since we are plotting the new middle graph based on PREVIOUS input, we look
    // at the last_trials&apos;s estimated_correlation and step size.)
    else if (last_trial.key_press &amp;&amp; (last_trial.key_press == trial.choices[0] || last_trial.key_press == trial.choices[1])){

      // Need to check that if hits either high or low ref, it DOESN&apos;T count as a num_adjustment
      let is_unchanged = false;

      switch (last_trial.key_press){

        case trial.choices[0]: // up

          estimated_correlation = Math.min(constants.high_ref, last_trial.estimated_mid + (Math.random() * last_trial.step_size));
          
          // If they&apos;ve hit the max (high_ref)
          if (estimated_correlation === constants.high_ref) {
            is_unchanged = true;
          }
          break;

        case trial.choices[1]: // down

          estimated_correlation = Math.max(constants.low_ref, last_trial.estimated_mid - (Math.random() * last_trial.step_size));
          
          // If they&apos;ve hit the min (low_ref)
          if (estimated_correlation === constants.low_ref) {
            is_unchanged = true;
          }
          break;
      }

      // For valid changes (i.e not going beyond max or below min), can then 
      // increment num_adjustments
      if (!is_unchanged){
        trial.data.num_adjustments = last_trial.num_adjustments + 1;
        this.input_count_array[trial.data.trial_num]++;
      }  

    }

    // Else use the previous trial&apos;s midpoint
    else{

      // QUESTION: If there is user input, on the next viz, the graph will display 
      // that estimated correlation. However, AFTER that, we are changing the 
      // estimated correlation??

      // Based on StevensTrial.java (line 75), the estimated midpoint gets updated this way:
      // var prev_constants = this.sub_conditions_constants[current_sub_condition_index-1];
      // if (last_trial.estimated_correlation == prev_constants.high_ref){
      //   estimated_midpoint = constants.low_ref;
      // }
      // else{
      //   estimated_midpoint = constants.high_ref;
      // }

      estimated_correlation = last_trial.estimated_mid;
    }

    // Update the trial&apos;s estimated_mid
    trial.data.estimated_mid = estimated_correlation;

    return estimated_correlation;
  }

  /**
   * Determines whether the round can end or not. A round can end ONLY if
   * there has been at least 1 input from the user on the given round 
   *
   * @return {boolean}            True if sub condition should end.
   */
  end_round() {

    let last_trial = jsPsych.data.get().last(1).values()[0];

    return !(last_trial.num_adjustments === 0);
  }

  /**
   * Determines whether the current sub condition can end or not.
   * 
   * @return {boolean}            True if sub condition should end.
   */
  end_sub_condition() {
    
    var trials_per_round = this.sub_conditions_constants[0].trials_per_round;
    
    if (this.input_count_array[trials_per_round - 1] == 0){ 
      return false;
    }
    else{
      // Reset array
      this.input_count_array = new Array(this.sub_conditions_constants[0].trials_per_round).fill(0);
      return true;
    }
  }

  /**
   * When called, will save individual trial data into a CSV.     
   */
  export_trial_data() {

    var csv = &apos;condition,trial_num,sub_condition,balanced_sub_condition,high_ref,estimated_mid,low_ref,num_adjustments,trials_per_round,error,sum_rt,num_points,mean,SD,num_SD,round_type,step_size,point_color,background_color,text_color,axis_color,point_size,regen_rate\n&apos;;
    // Get most recent subcondition - will have the max subcondition value
    var max_sub_condition = jsPsych.data.get().filter({type: &apos;stevens&apos;, run_type: &apos;test&apos;}).last(1).values()[0].sub_condition;
    var data = [];

    // Iterate through each sub condition
    for (let i = 0; i&lt;=max_sub_condition; i++){
      var condition_data = jsPsych.data.get().filter({type: &apos;stevens&apos;, run_type: &apos;test&apos;, sub_condition: i})
                                             .filterCustom(function(x){ //Don&apos;t include trials with no user input
                                                return x.rt != null;
                                             });                                
      var condition_values = condition_data.values()[0];
      var max_trial_num = condition_data.last(1).values()[0].trial_num; //The last trial of this sub-condition
                                                                        //has the last trial num
      // Iterate through each trial of a given sub condition                                                               
      for (let j = 0; j&lt;=max_trial_num; j++){
        //Data for a given trial of a sub condition
        var trial_data = condition_data.filter({trial_num: j});
        //Take the last trial&apos;s estimated mid since we want the most recent value
        var last_estimated_mid = trial_data.last(1).values()[0].estimated_mid;
        var last_num_adjustments = trial_data.last(1).values()[0].num_adjustments;
        var sum_rt = trial_data.filterCustom(function(x){ return x.key_press != 81 }) //Don&apos;t use the exit trial rt
                                   .select(&apos;rt&apos;)
                                   .sum();
                                              
        var row = [this.condition_name];

        row.push(j+1);
        row.push(condition_values.sub_condition);
        row.push(condition_values.balanced_sub_condition);
        row.push(condition_values.high_ref);
        row.push(last_estimated_mid);
        row.push(condition_values.low_ref);
        row.push(last_num_adjustments);
        row.push(condition_values.trials_per_round);
        row.push(condition_values.error);
        row.push(average_rt);
        row.push(condition_values.num_points);
        row.push(condition_values.mean);
        row.push(condition_values.SD);
        row.push(condition_values.num_SD);
        row.push(condition_values.round_type);
        row.push(condition_values.step_size);
        row.push(condition_values.point_color);
        row.push(condition_values.background_color);
        row.push(condition_values.text_color);
        row.push(condition_values.axis_color);
        row.push(condition_values.point_size);
        row.push(condition_values.regen_rate);

        data.push(row);
      }
    }

    // Append each row
    data.forEach(function(row){
      csv += row.join(&apos;,&apos;);
      csv += &quot;\n&quot;;
    });

    var hiddenElement = document.createElement(&apos;a&apos;);
    hiddenElement.href = &apos;data:text/csv;charset=utf-8,&apos; + encodeURI(csv);
    hiddenElement.target = &apos;_blank&apos;;
    hiddenElement.download = &quot;S&quot; + this.subject_id + &quot;_&quot; +this.condition_name + &quot;_stevens_trial_results.csv&quot;;
    hiddenElement.click();
  }

  /**
   * When called, will save aggregated trial data into a CSV.     
   */
  export_summary_data() {
    var csv = &apos;SUBJECT_ID,SUBJECT_INITIALS,ROUND_TYPE,NUM_TRIALS,HIGH_REF,ESTIMATED_MIDPOINT,LOW_REF\n&apos;;

    var data = [];
    
    // Organize each row of the csv
    for (let i = 0; i&lt;this.sub_conditions_constants.length; i++){
      var row = [];
      var constants = this.sub_conditions_constants[i];
      var condition_data = jsPsych.data.get().filter({type: &apos;stevens&apos;, run_type: &apos;test&apos;, balanced_sub_condition: this.sub_condition_order[i]})
                                             .filterCustom(function(x){ //Don&apos;t include the exit trials
                                                return x.correct != -1; 
                                             })
                                             .filterCustom(function(x){ //Don&apos;t include trials with no user input
                                                return x.rt != null;
                                             });

      row.push(this.subject_id);
      row.push(this.subject_initials);
      row.push(constants.round_type);
      row.push(constants.trials_per_round);
      row.push(constants.high_ref);
      row.push(condition_data.select(&apos;estimated_mid&apos;).mean());
      row.push(constants.low_ref);  

      data.push(row);
    }

    // Append each row
    data.forEach(function(row){
      csv += row.join(&apos;,&apos;);
      csv += &quot;\n&quot;;
    });

    var hiddenElement = document.createElement(&apos;a&apos;);
    hiddenElement.href = &apos;data:text/csv;charset=utf-8,&apos; + encodeURI(csv);
    hiddenElement.target = &apos;_blank&apos;;
    hiddenElement.download = &quot;S&quot; + this.subject_id + &quot;_&quot; + this.condition_name + &quot;_stevens_summary_results.csv&quot;;
    hiddenElement.click();
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
